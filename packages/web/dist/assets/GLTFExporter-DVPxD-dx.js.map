{"version":3,"file":"GLTFExporter-DVPxD-dx.js","sources":["../../../../node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tCompressedTexture,\n\tVector3,\n\tQuaternion,\n\tREVISION,\n\tImageUtils\n} from 'three';\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n/**\n * An exporter for `glTF` 2.0.\n *\n * glTF (GL Transmission Format) is an [open format specification]{@link https://github.com/KhronosGroup/glTF/tree/master/specification/2.0}\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf)\n * or binary (.glb) format. External files store textures (.jpg, .png) and additional binary\n * data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials,\n * textures, skins, skeletons, morph targets, animations, lights, and/or cameras.\n *\n * GLTFExporter supports the [glTF 2.0 extensions]{@link https://github.com/KhronosGroup/glTF/tree/master/extensions/}:\n *\n * - KHR_lights_punctual\n * - KHR_materials_clearcoat\n * - KHR_materials_dispersion\n * - KHR_materials_emissive_strength\n * - KHR_materials_ior\n * - KHR_materials_iridescence\n * - KHR_materials_specular\n * - KHR_materials_sheen\n * - KHR_materials_transmission\n * - KHR_materials_unlit\n * - KHR_materials_volume\n * - KHR_mesh_quantization\n * - KHR_texture_transform\n * - EXT_materials_bump\n * - EXT_mesh_gpu_instancing\n *\n * The following glTF 2.0 extension is supported by an external user plugin:\n *\n * - [KHR_materials_variants]{@link https://github.com/takahirox/three-gltf-extensions}\n *\n * ```js\n * const exporter = new GLTFExporter();\n * const data = await exporter.parseAsync( scene, options );\n * ```\n *\n * @three_import import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';\n */\nclass GLTFExporter {\n\n\t/**\n\t * Constructs a new glTF exporter.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A reference to a texture utils module.\n\t\t *\n\t\t * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( writer );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Registers a plugin callback. This API is internally used to implement the various\n\t * glTF extensions but can also used by third-party code to add additional logic\n\t * to the exporter.\n\t *\n\t * @param {function(writer:GLTFWriter)} callback - The callback function to register.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Unregisters a plugin callback.\n\t *\n\t * @param {Function} callback - The callback function to unregister.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n\t *\n\t * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n\t * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n\t *\n\t * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given scenes and generates the glTF output.\n\t *\n\t * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n\t * @param {GLTFExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {GLTFExporter~OnError} onError - A callback function that is executed when an error happens.\n\t * @param {GLTFExporter~Options} options - options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.setTextureUtils( this.textureUtils );\n\t\twriter.writeAsync( input, onDone, options ).catch( onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link GLTFExporter#parse}.\n\t *\n\t * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n\t * @param {GLTFExporter~Options} options - options.\n\t * @return {Promise<ArrayBuffer|string>} A Promise that resolved with the exported glTF data.\n\t */\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n *\n * @private\n * @param {Array} array1 Array 1 to compare\n * @param {Array} array2 Array 2 to compare\n * @return {boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @private\n * @param {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @private\n * @param {Matrix4} matrix\n * @returns {boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n *\n * @private\n * @param {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param {number} start Start index\n * @param {number} count Range to cover\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @private\n * @param {number} bufferSize The size the original buffer. Should be an integer.\n * @returns {number} new buffer size with required padding as an integer.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {number} [paddingByte=0] Should be an integer\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas ) {\n\n\t\tlet quality;\n\n\t\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\t\tif ( mimeType === 'image/jpeg' ) {\n\n\t\t\tquality = 0.92;\n\n\t\t} else if ( mimeType === 'image/webp' ) {\n\n\t\t\tquality = 0.8;\n\n\t\t}\n\n\t\treturn canvas.convertToBlob( {\n\n\t\t\ttype: mimeType,\n\t\t\tquality: quality\n\n\t\t} );\n\n\t} else {\n\n\t\t// HTMLCanvasElement code path\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n}\n\n/**\n * Writer\n *\n * @private\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter r' + REVISION\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t\tthis.textureUtils = null;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t *\n\t * @param {Scene|Array<Scene>} input Scene or Array of THREE.Scenes\n\t * @param {Function} onDone Callback on completed\n\t * @param {Object} options options\n\t */\n\tasync writeAsync( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tawait this.processInputAsync( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry|THREE.AnimationClip} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t *\n\t * @param {Object} attribute\n\t * @param {boolean} [isRelativeCopy=false]\n\t * @return {number} An integer\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tasync buildMetalRoughTextureAsync( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\n\n\t\t\tmetalnessMap = await this.decompressTextureAsync( metalnessMap );\n\n\t\t}\n\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\n\n\t\t\troughnessMap = await this.decompressTextureAsync( roughnessMap );\n\n\t\t}\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d', {\n\t\t\twillReadFrequently: true,\n\t\t} );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\treturn texture;\n\n\t}\n\n\n\tasync decompressTextureAsync( texture, maxTextureSize = Infinity ) {\n\n\t\tif ( this.textureUtils === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.' );\n\n\t\t}\n\n\t\treturn await this.textureUtils.decompress( texture, maxTextureSize );\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param {ArrayBuffer} buffer\n\t * @return {0}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param {BufferAttribute} attribute\n\t * @param {number} componentType\n\t * @param {number} start\n\t * @param {number} count\n\t * @param {number} [target] Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tlet byteStride = attribute.itemSize * componentSize;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n\t\t\t// inside a bufferView\n\t\t\tbyteStride = Math.ceil( byteStride / 4 ) * 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * byteStride );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t\tif ( ( offset % byteStride ) !== 0 ) {\n\n\t\t\t\toffset += byteStride - ( offset % byteStride );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = byteStride;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<number>} An integer\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param {BufferAttribute} attribute Attribute to process\n\t * @param {?BufferGeometry} [geometry] Geometry used for truncated draw range\n\t * @param {number} [start=0]\n\t * @param {number} [count=Infinity]\n\t * @return {?number} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined || count === Infinity ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param {Image} image to process\n\t * @param {number} format Identifier of the format (RGBAFormat)\n\t * @param {boolean} flipY before writing out the image\n\t * @param {string} mimeType export format\n\t * @return {number}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\twillReadFrequently: true,\n\t\t\t} );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\timageDef.uri = ImageUtils.getDataURL( canvas, mimeType );\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param {Texture} map Texture to process\n\t * @return {number}      Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param {Texture} map Map to process\n\t * @return {Promise<number>} Index of the processed texture in the \"textures\" array\n\t */\n\tasync processTextureAsync( map ) {\n\n\t\tconst writer = this;\n\t\tconst options = writer.options;\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n\t\tif ( map instanceof CompressedTexture ) {\n\n\t\t\tmap = await this.decompressTextureAsync( map, options.maxTextureSize );\n\n\t\t}\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeTexture && await ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param {THREE.Material} material Material to process\n\t * @return {Promise<?number>} Index of the processed material in the \"materials\" array\n\t */\n\tasync processMaterialAsync( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 1;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = await this.buildMetalRoughTextureAsync( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( metalRoughTexture ),\n\t\t\t\ttexCoord: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: await this.processTextureAsync( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeMaterialAsync && await ext.writeMaterialAsync( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param {THREE.Mesh} mesh Mesh to process\n\t * @return {Promise<?number>} Index of the processed mesh in the \"meshes\" array\n\t */\n\tasync processMeshAsync( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tuv2: 'TEXCOORD_2',\n\t\t\tuv3: 'TEXCOORD_3',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Enforce glTF vertex attribute requirements:\n\t\t\t// - JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT\n\t\t\t// - Only custom attributes may be INT or UNSIGNED_INT\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t} else if ( ( array instanceof Uint32Array || array instanceof Int32Array ) && ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\tconsole.warn( `GLTFExporter: Attribute \"${ attributeName }\" converted to type FLOAT.` );\n\t\t\t\tmodifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tlet didForceIndices = false;\n\n\t\tif ( isMultiMaterial && geometry.index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\tindices[ i ] = i;\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\n\t\t\tdidForceIndices = true;\n\n\t\t}\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = await this.processMaterialAsync( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tif ( didForceIndices === true ) {\n\n\t\t\tgeometry.setIndex( null );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param {THREE.Camera} camera Camera to process\n\t * @return {number} Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {?number}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tconst animationDef = {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t};\n\n\t\tthis.serializeUserData( clip, animationDef );\n\n\t\tjson.animations.push( animationDef );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {?number}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param {THREE.Object3D} object Object3D to processNodeAsync\n\t * @return {Promise<number>} Index of the node in the nodes list\n\t */\n\tasync processNodeAsync( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = await this.processMeshAsync( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst childNodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\t\tif ( childNodeIndex !== null ) children.push( childNodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param {Scene} scene Scene to process\n\t */\n\tasync processSceneAsync( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param {Array<THREE.Object3D>} objects List of objects to process\n\t */\n\tasync processObjectsAsync( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tawait this.processSceneAsync( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tasync processInputAsync( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tawait this.processSceneAsync( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\tawait this.processObjectsAsync( objectsWithoutScene );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\tasync _invokeAllAsync( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tawait func( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n *\n * @private\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n *\n * @private\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n *\n * @private\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\n *\n * @private\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_dispersion';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.dispersion = material.dispersion;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n *\n * @private\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n *\n * @private\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n *\n * @private\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\tif ( material.attenuationDistance !== Infinity ) {\n\n\t\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\n\t\t}\n\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n *\n * @private\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n *\n * @private\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n *\n * @private\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n *\n * @private\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_anisotropy';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.anisotropyMap ) {\n\n\t\t\tconst anisotropyMapDef = { index: await writer.processTextureAsync( material.anisotropyMap ) };\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\n\n\t\t}\n\n\t\textensionDef.anisotropyStrength = material.anisotropy;\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n *\n * @private\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n *\n * @private\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_materials_bump';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || (\n\t\t       material.bumpScale === 1 &&\n\t\t     ! material.bumpMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tconst bumpMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.bumpMap ),\n\t\t\t\ttexCoord: material.bumpMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( bumpMapDef, material.bumpMap );\n\t\t\textensionDef.bumpTexture = bumpMapDef;\n\n\t\t}\n\n\t\textensionDef.bumpFactor = material.bumpScale;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n * @private\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_mesh_gpu_instancing';\n\n\t}\n\n\twriteNode( object, nodeDef ) {\n\n\t\tif ( ! object.isInstancedMesh ) return;\n\n\t\tconst writer = this.writer;\n\n\t\tconst mesh = object;\n\n\t\tconst translationAttr = new Float32Array( mesh.count * 3 );\n\t\tconst rotationAttr = new Float32Array( mesh.count * 4 );\n\t\tconst scaleAttr = new Float32Array( mesh.count * 3 );\n\n\t\tconst matrix = new Matrix4();\n\t\tconst position = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3();\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tmesh.getMatrixAt( i, matrix );\n\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\tposition.toArray( translationAttr, i * 3 );\n\t\t\tquaternion.toArray( rotationAttr, i * 4 );\n\t\t\tscale.toArray( scaleAttr, i * 3 );\n\n\t\t}\n\n\t\tconst attributes = {\n\t\t\tTRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),\n\t\t\tROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),\n\t\t\tSCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),\n\t\t};\n\n\t\tif ( mesh.instanceColor )\n\t\t\tattributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { attributes };\n\n\t\twriter.extensionsUsed[ this.name ] = true;\n\t\twriter.extensionsRequired[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n *\n * @private\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t},\n\n\ttoFloat32BufferAttribute: function ( srcAttribute ) {\n\n\t\tconst dstAttribute = new BufferAttribute( new Float32Array( srcAttribute.count * srcAttribute.itemSize ), srcAttribute.itemSize, false );\n\n\t\tif ( ! srcAttribute.normalized && ! srcAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\tdstAttribute.array.set( srcAttribute.array );\n\n\t\t\treturn dstAttribute;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = srcAttribute.count; i < il; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < srcAttribute.itemSize; j ++ ) {\n\n\t\t\t\tdstAttribute.setComponent( i, j, srcAttribute.getComponent( i, j ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dstAttribute;\n\n\t}\n\n};\n\n/**\n * Export options of `GLTFExporter`.\n *\n * @typedef {Object} GLTFExporter~Options\n * @property {boolean} [trs=false] - Export position, rotation and scale instead of matrix per node.\n * @property {boolean} [onlyVisible=true] - Export only visible 3D objects.\n * @property {boolean} [binary=false] - Export in binary (.glb) format, returning an ArrayBuffer.\n * @property {number} [maxTextureSize=Infinity] - Restricts the image maximum size (both width and height) to the given value.\n * @property {Array<AnimationClip>} [animations=[]] - List of animations to be included in the export.\n * @property {boolean} [includeCustomExtensions=false] - Export custom glTF extensions defined on an object's `userData.gltfExtensions` property.\n **/\n\n/**\n * onDone callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnDone\n * @param {ArrayBuffer|string} result - The generated .gltf (JSON) or .glb (binary).\n */\n\n/**\n * onError callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { GLTFExporter };\n"],"names":["KHR_mesh_quantization_ExtraAttrTypes","GLTFExporter","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsBumpExtension","GLTFMeshGpuInstancing","callback","utils","input","onDone","onError","options","GLTFWriter","plugins","i","il","scope","resolve","reject","WEBGL_CONSTANTS","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","PATH_PROPERTIES","DEFAULT_SPECULAR_COLOR","Color","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","element","index","stringToArrayBuffer","text","isIdentityMatrix","matrix","getMinMax","attribute","start","count","output","a","value","MathUtils","getPaddedBufferSize","bufferSize","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","array","getCanvas","getToBlobPromise","canvas","mimeType","quality","REVISION","buffers","json","extensionsUsed","extensionsRequired","blob","extensionsUsedList","extensionsRequiredList","reader","binaryChunk","binaryChunkPrefix","jsonChunk","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","base64data","object","objectDef","extensionName","error","isRelativeCopy","uids","normal","v","Vector3","cache","mapDef","texture","didTransform","transformDef","metalnessMap","roughnessMap","getEncodingConversion","map","SRGBColorSpace","c","CompressedTexture","metalness","roughness","width","height","context","composite","convert","data","Source","NoColorSpace","maxTextureSize","buffer","componentType","target","componentSize","byteStride","byteLength","dataView","offset","bufferViewDef","geometry","types","minMax","bufferViewTarget","bufferView","accessorDef","image","format","flipY","pending","cachedImages","key","imageDef","ctx","RGBAFormat","bufferViewIndex","ImageUtils","samplerDef","textureDef","ext","material","materialDef","color","metalRoughTexture","metalRoughMapDef","baseColorMapDef","emissive","emissiveMapDef","normalMapDef","occlusionMapDef","DoubleSide","mesh","meshCacheKeyParts","l","meshCacheKey","mode","meshDef","attributes","primitives","targets","nameConversion","originalNormal","modifiedAttribute","attributeName","BufferAttribute","accessor","weights","targetNames","reverseDictionary","warned","gltfAttributeName","baseAttribute","relativeAttribute","j","jl","isMultiMaterial","didForceIndices","indices","materials","groups","primitive","cacheKey","attrType","attrNamePrefix","camera","isOrtho","cameraDef","clip","root","nodeMap","tracks","channels","samplers","track","trackBinding","PropertyBinding","trackNode","trackProperty","inputItemSize","outputItemSize","interpolation","InterpolateDiscrete","animationDef","node","skeleton","rootJoint","joints","inverseBindMatrices","temporaryBoneInverse","Matrix4","nodeDef","rotation","position","scale","meshIndex","nodeIndex","children","child","childNodeIndex","scene","sceneDef","nodes","objects","Scene","objectsWithoutScene","func","light","lightDef","lights","extensionDef","clearcoatMapDef","clearcoatRoughnessMapDef","clearcoatNormalMapDef","iridescenceMapDef","iridescenceThicknessMapDef","transmissionMapDef","thicknessMapDef","specularIntensityMapDef","specularColorMapDef","sheenRoughnessMapDef","sheenColorMapDef","anisotropyMapDef","bumpMapDef","translationAttr","rotationAttr","scaleAttr","quaternion","Quaternion","time","valueSize","times","values","interpolant","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","InterpolateLinear","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex","srcAttribute","dstAttribute"],"mappings":"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","x_google_ignoreList":[0]}